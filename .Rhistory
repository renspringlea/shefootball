# Load packages
library(rvest) # for web scraping
library(httr) # for web scraping
library(RSelenium) # for web scraping pages that use javascript-rendered content
library(gsheet) # for downloading the pre-prepared spreadsheet data
library(netstat) # helps web scraping by finding free ports
library(R.utils) # provides the function to time out loops
library(readr) # for saving text files
# Use large language model to assign to cage or cage-free
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables_preprocess",
full.names=T)
data_table_files
for (i in c(40:length(data_table_files))){
print(paste0("Data table: ",i," of ",length(data_table_files)))
df_products_tmp <- read.csv(data_table_files[i])
for (j in c(1:nrow(df_products_tmp))){
print(paste0("Calling LLM for product ",j," of ",nrow(df_products_tmp)))
# Set up prompt
gemini_prompt_tmp <- paste0("
I will give you the name corresponding to a specific egg product
from an online retailer. Using the information I've given you, assign this product
to one of seven categories: 'cage', 'barn', 'aviary', 'free-range', 'organic', 'cage-free not identified',
or 'insufficient information'. Any product that is cage-free should be assigned to either 'barn',
'aviary', 'free-range', 'organic', or 'cage-free not identified' based on the product name and information. If the product is clearly
cage-free but unable to be assigned to one of cage-free categories, simply report 'cage-free not identified'.
Any product produced in a cage is 'cage'. If you cannot discern whether it is caged or cage-free from the
product name and description, simply say 'insufficient information'.
Only use the category 'organic' if the item is clearly organic and if that item cannot be assigned
to one of the other cage-free categories (barn, aviary, free-range).
Do not include any explanation or any other information in your assessment -
simply reply with one of 'cage', 'barn', 'aviary', 'free-range', 'organic',
'cage-free not identified', or 'insufficient information'.
Format your answer to exactly match one of those seven character
strings; do not capitalise or include any additional whitespace.
The name is: ",df_products_tmp[j,"product_name"])
# Set up temporary files
llm_prompt_tempfile <- tempfile(fileext=".txt")
llm_prompt_tempfile2 <-  tempfile(fileext=".txt")
writeLines(gemini_prompt_tmp,llm_prompt_tempfile)
# Call the large language model (Gemini) from the system
# Randomly choosing from 2 different models to avoid hitting API limits
#gemini_model <- sample(c("gemini-1.5-flash-001","gemini-1.5-flash-8b-latest","gemini-2.0-flash-exp"),1)
#system(paste0("cat ",llm_prompt_tempfile," | llm -m ",gemini_model," > ",llm_prompt_tempfile2))
system(paste0("cat ",llm_prompt_tempfile," | gemini > ",llm_prompt_tempfile2))
# Pause to avoid sending requests to Gemini too quickly
Sys.sleep(5)
# Read in the response and store in data frame
gemini_response_tmp <- trimws(paste(readLines(llm_prompt_tempfile2),collapse=""))
df_products_tmp[j,"production_system"] <- gemini_response_tmp
# Create a flag that equals TRUE if Gemini has failed to obey its instructions
# which can then be manually reviewed
df_products_tmp[j,"flag"] <- !(gemini_response_tmp %in% c("cage","barn","aviary","organic",
"free-range","cage-free not identified",
"insufficient information"))
} #j
write.csv(df_products_tmp,gsub("_preprocess","",data_table_files[i]),row.names=F)
}
for (i in c(40:length(data_table_files))){
print(paste0("Data table: ",i," of ",length(data_table_files)))
df_products_tmp <- read.csv(data_table_files[i])
for (j in c(1:nrow(df_products_tmp))){
print(paste0("Calling LLM for product ",j," of ",nrow(df_products_tmp)))
# Set up prompt
gemini_prompt_tmp <- paste0("
I will give you the name corresponding to a specific egg product
from an online retailer. Using the information I've given you, assign this product
to one of seven categories: 'cage', 'barn', 'aviary', 'free-range', 'organic', 'cage-free not identified',
or 'insufficient information'. Any product that is cage-free should be assigned to either 'barn',
'aviary', 'free-range', 'organic', or 'cage-free not identified' based on the product name and information. If the product is clearly
cage-free but unable to be assigned to one of cage-free categories, simply report 'cage-free not identified'.
Any product produced in a cage is 'cage'. If you cannot discern whether it is caged or cage-free from the
product name and description, simply say 'insufficient information'.
Only use the category 'organic' if the item is clearly organic and if that item cannot be assigned
to one of the other cage-free categories (barn, aviary, free-range).
Do not include any explanation or any other information in your assessment -
simply reply with one of 'cage', 'barn', 'aviary', 'free-range', 'organic',
'cage-free not identified', or 'insufficient information'.
Format your answer to exactly match one of those seven character
strings; do not capitalise or include any additional whitespace.
The name is: ",df_products_tmp[j,"product_name"])
# Set up temporary files
llm_prompt_tempfile <- tempfile(fileext=".txt")
llm_prompt_tempfile2 <-  tempfile(fileext=".txt")
writeLines(gemini_prompt_tmp,llm_prompt_tempfile)
# Call the large language model (Gemini) from the system
# Randomly choosing from 2 different models to avoid hitting API limits
#gemini_model <- sample(c("gemini-1.5-flash-001","gemini-1.5-flash-8b-latest","gemini-2.0-flash-exp"),1)
#system(paste0("cat ",llm_prompt_tempfile," | llm -m ",gemini_model," > ",llm_prompt_tempfile2))
system(paste0("cat ",llm_prompt_tempfile," | gemini > ",llm_prompt_tempfile2))
# Pause to avoid sending requests to Gemini too quickly
Sys.sleep(5)
# Read in the response and store in data frame
gemini_response_tmp <- trimws(paste(readLines(llm_prompt_tempfile2),collapse=""))
df_products_tmp[j,"production_system"] <- gemini_response_tmp
# Create a flag that equals TRUE if Gemini has failed to obey its instructions
# which can then be manually reviewed
df_products_tmp[j,"flag"] <- !(gemini_response_tmp %in% c("cage","barn","aviary","organic",
"free-range","cage-free not identified",
"insufficient information"))
} #j
write.csv(df_products_tmp,gsub("_preprocess","",data_table_files[i]),row.names=F)
}
for (i in c(40:length(data_table_files))){
print(paste0("Data table: ",i," of ",length(data_table_files)))
df_products_tmp <- read.csv(data_table_files[i])
for (j in c(1:nrow(df_products_tmp))){
print(paste0("Calling LLM for product ",j," of ",nrow(df_products_tmp)))
# Set up prompt
gemini_prompt_tmp <- paste0("
I will give you the name corresponding to a specific egg product
from an online retailer. Using the information I've given you, assign this product
to one of seven categories: 'cage', 'barn', 'aviary', 'free-range', 'organic', 'cage-free not identified',
or 'insufficient information'. Any product that is cage-free should be assigned to either 'barn',
'aviary', 'free-range', 'organic', or 'cage-free not identified' based on the product name and information. If the product is clearly
cage-free but unable to be assigned to one of cage-free categories, simply report 'cage-free not identified'.
Any product produced in a cage is 'cage'. If you cannot discern whether it is caged or cage-free from the
product name and description, simply say 'insufficient information'.
Only use the category 'organic' if the item is clearly organic and if that item cannot be assigned
to one of the other cage-free categories (barn, aviary, free-range).
Do not include any explanation or any other information in your assessment -
simply reply with one of 'cage', 'barn', 'aviary', 'free-range', 'organic',
'cage-free not identified', or 'insufficient information'.
Format your answer to exactly match one of those seven character
strings; do not capitalise or include any additional whitespace.
The name is: ",df_products_tmp[j,"product_name"])
# Set up temporary files
llm_prompt_tempfile <- tempfile(fileext=".txt")
llm_prompt_tempfile2 <-  tempfile(fileext=".txt")
writeLines(gemini_prompt_tmp,llm_prompt_tempfile)
# Call the large language model (Gemini) from the system
# Randomly choosing from 2 different models to avoid hitting API limits
#gemini_model <- sample(c("gemini-1.5-flash-001","gemini-1.5-flash-8b-latest","gemini-2.0-flash-exp"),1)
#system(paste0("cat ",llm_prompt_tempfile," | llm -m ",gemini_model," > ",llm_prompt_tempfile2))
system(paste0("cat ",llm_prompt_tempfile," | gemini > ",llm_prompt_tempfile2))
# Pause to avoid sending requests to Gemini too quickly
Sys.sleep(5)
# Read in the response and store in data frame
gemini_response_tmp <- trimws(paste(readLines(llm_prompt_tempfile2),collapse=""))
df_products_tmp[j,"production_system"] <- gemini_response_tmp
# Create a flag that equals TRUE if Gemini has failed to obey its instructions
# which can then be manually reviewed
df_products_tmp[j,"flag"] <- !(gemini_response_tmp %in% c("cage","barn","aviary","organic",
"free-range","cage-free not identified",
"insufficient information"))
} #j
write.csv(df_products_tmp,gsub("_preprocess","",data_table_files[i]),row.names=F)
}
# Load packages
library(rvest) # for web scraping
library(httr) # for web scraping
library(RSelenium) # for web scraping pages that use javascript-rendered content
library(gsheet) # for downloading the pre-prepared spreadsheet data
library(netstat) # helps web scraping by finding free ports
library(R.utils) # provides the function to time out loops
library(readr) # for saving text files
# Use large language model to assign to cage or cage-free
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables_preprocess",
full.names=T)
for (i in c(55:length(data_table_files))){
print(paste0("Data table: ",i," of ",length(data_table_files)))
df_products_tmp <- read.csv(data_table_files[i])
for (j in c(1:nrow(df_products_tmp))){
print(paste0("Calling LLM for product ",j," of ",nrow(df_products_tmp)))
# Set up prompt
gemini_prompt_tmp <- paste0("
I will give you the name corresponding to a specific egg product
from an online retailer. Using the information I've given you, assign this product
to one of seven categories: 'cage', 'barn', 'aviary', 'free-range', 'organic', 'cage-free not identified',
or 'insufficient information'. Any product that is cage-free should be assigned to either 'barn',
'aviary', 'free-range', 'organic', or 'cage-free not identified' based on the product name and information. If the product is clearly
cage-free but unable to be assigned to one of cage-free categories, simply report 'cage-free not identified'.
Any product produced in a cage is 'cage'. If you cannot discern whether it is caged or cage-free from the
product name and description, simply say 'insufficient information'.
Only use the category 'organic' if the item is clearly organic and if that item cannot be assigned
to one of the other cage-free categories (barn, aviary, free-range).
Do not include any explanation or any other information in your assessment -
simply reply with one of 'cage', 'barn', 'aviary', 'free-range', 'organic',
'cage-free not identified', or 'insufficient information'.
Format your answer to exactly match one of those seven character
strings; do not capitalise or include any additional whitespace.
The name is: ",df_products_tmp[j,"product_name"])
# Set up temporary files
llm_prompt_tempfile <- tempfile(fileext=".txt")
llm_prompt_tempfile2 <-  tempfile(fileext=".txt")
writeLines(gemini_prompt_tmp,llm_prompt_tempfile)
# Call the large language model (Gemini) from the system
# Randomly choosing from 2 different models to avoid hitting API limits
#gemini_model <- sample(c("gemini-1.5-flash-001","gemini-1.5-flash-8b-latest","gemini-2.0-flash-exp"),1)
#system(paste0("cat ",llm_prompt_tempfile," | llm -m ",gemini_model," > ",llm_prompt_tempfile2))
system(paste0("cat ",llm_prompt_tempfile," | gemini > ",llm_prompt_tempfile2))
# Pause to avoid sending requests to Gemini too quickly
Sys.sleep(5)
# Read in the response and store in data frame
gemini_response_tmp <- trimws(paste(readLines(llm_prompt_tempfile2),collapse=""))
df_products_tmp[j,"production_system"] <- gemini_response_tmp
# Create a flag that equals TRUE if Gemini has failed to obey its instructions
# which can then be manually reviewed
df_products_tmp[j,"flag"] <- !(gemini_response_tmp %in% c("cage","barn","aviary","organic",
"free-range","cage-free not identified",
"insufficient information"))
} #j
write.csv(df_products_tmp,gsub("_preprocess","",data_table_files[i]),row.names=F)
}
# Load packages
library(scales) # For making numbers pretty
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables",
full.names=T)
for (i in c(1:length(data_table_files))){
csv_tmp <- read.csv(data_table_files[i])
if(exists("df_all_countries")){
df_all_countries <- rbind(df_all_countries,csv_tmp)
} else {
df_all_countries <- csv_tmp
}
}
# Remove rows corresponding to duck eggs, quail eggs, chocolate eggs
strings_to_remove <- c("quail", "Bıldırcın", "うずら", "codorniz", "duck", "เป็ด","pato", "chocolate", "çikolat")
strings_to_remove_regex <- paste(strings_to_remove,sep="",collapse="|")
rows_to_remove <- which(grepl(strings_to_remove_regex,df_all_countries$product_name))
if(length(rows_to_remove)>0){
df_all_countries <- df_all_countries[-rows_to_remove,]
}
# List any rows that have a positive flag
# or where the production system was not given
# (which require manual review and may require manual modification of the data
# CSV files)
df_all_countries[which(df_all_countries$flag),]
df_all_countries[which(is.na(df_all_countries$production_system)),]
rm(list=ls())
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables",
full.names=T)
for (i in c(1:length(data_table_files))){
csv_tmp <- read.csv(data_table_files[i])
if(exists("df_all_countries")){
df_all_countries <- rbind(df_all_countries,csv_tmp)
} else {
df_all_countries <- csv_tmp
}
}
# Remove rows corresponding to duck eggs, quail eggs, chocolate eggs
strings_to_remove <- c("quail", "Bıldırcın", "うずら", "codorniz", "duck", "เป็ด","pato", "chocolate", "çikolat")
strings_to_remove_regex <- paste(strings_to_remove,sep="",collapse="|")
rows_to_remove <- which(grepl(strings_to_remove_regex,df_all_countries$product_name))
if(length(rows_to_remove)>0){
df_all_countries <- df_all_countries[-rows_to_remove,]
}
# List any rows that have a positive flag
# or where the production system was not given
# (which require manual review and may require manual modification of the data
# CSV files)
df_all_countries[which(df_all_countries$flag),]
rm(list=ls())
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables",
full.names=T)
for (i in c(1:length(data_table_files))){
csv_tmp <- read.csv(data_table_files[i])
if(exists("df_all_countries")){
df_all_countries <- rbind(df_all_countries,csv_tmp)
} else {
df_all_countries <- csv_tmp
}
}
# Remove rows corresponding to duck eggs, quail eggs, chocolate eggs
strings_to_remove <- c("quail", "Bıldırcın", "うずら", "codorniz", "duck", "เป็ด","pato", "chocolate", "çikolat")
strings_to_remove_regex <- paste(strings_to_remove,sep="",collapse="|")
rows_to_remove <- which(grepl(strings_to_remove_regex,df_all_countries$product_name))
if(length(rows_to_remove)>0){
df_all_countries <- df_all_countries[-rows_to_remove,]
}
# List any rows that have a positive flag
# or where the production system was not given
# (which require manual review and may require manual modification of the data
# CSV files)
df_all_countries[which(df_all_countries$flag),]
df_all_countries[which(is.na(df_all_countries$production_system)),]
# Match with the original URL spreadsheet to note which countries have commitments/are reporting
df_urls <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1q4MWXWUEn3W9PY7NOmvnM1uF2Qn2qgZ7zc9hSIUiGxM/edit?gid=675609731#gid=675609731")
df_urls <- as.data.frame(df_urls)
#df_urls <- read.csv("~/cagefree/Countries targeted for data collection (cage-free products web scrape) - Retailer URLs.csv")
f_commitment <- function(country2,chain2){
tmp_commitment <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"commitment"])
tmp_reporting <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"reporting"])
if(length(tmp_commitment)>1){tmp_commitment <- tmp_commitment[1]}
if(length(tmp_reporting)>1){tmp_reporting <- tmp_reporting[1]}
if(tmp_commitment & tmp_reporting){return("Has commitment and is reporting")}
if(tmp_commitment & !(tmp_reporting)){return("Has commitment but is not reporting")}
if(!(tmp_commitment) & !(tmp_reporting)){return("Has no commitment and is not reporting")}
if(!(tmp_commitment) & tmp_reporting){return("Has no commitment but is reporting")}
}
df_all_countries$commitment <- ""
for (i in c(1:nrow(df_all_countries))){
df_all_countries$commitment[i] <- f_commitment(df_all_countries$country[i],df_all_countries$chain[i])
}
for (i in c(1:nrow(df_all_countries))){
print(i)
df_all_countries$commitment[i] <- f_commitment(df_all_countries$country[i],df_all_countries$chain[i])
}
nrow(df_all_countries)
df_all_countries[1841,]
View(df_urls)
###############################
### Analysis of web scrapes ###
###############################
rm(list=ls())
# Load packages
library(scales) # For making numbers pretty
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables",
full.names=T)
for (i in c(1:length(data_table_files))){
csv_tmp <- read.csv(data_table_files[i])
if(exists("df_all_countries")){
df_all_countries <- rbind(df_all_countries,csv_tmp)
} else {
df_all_countries <- csv_tmp
}
}
# Remove rows corresponding to duck eggs, quail eggs, chocolate eggs
strings_to_remove <- c("quail", "Bıldırcın", "うずら", "codorniz", "duck", "เป็ด","pato", "chocolate", "çikolat")
strings_to_remove_regex <- paste(strings_to_remove,sep="",collapse="|")
rows_to_remove <- which(grepl(strings_to_remove_regex,df_all_countries$product_name))
if(length(rows_to_remove)>0){
df_all_countries <- df_all_countries[-rows_to_remove,]
}
# List any rows that have a positive flag
# or where the production system was not given
# (which require manual review and may require manual modification of the data
# CSV files)
df_all_countries[which(df_all_countries$flag),]
df_all_countries[which(is.na(df_all_countries$production_system)),]
# Match with the original URL spreadsheet to note which countries have commitments/are reporting
df_urls <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1q4MWXWUEn3W9PY7NOmvnM1uF2Qn2qgZ7zc9hSIUiGxM/edit?gid=675609731#gid=675609731")
df_urls <- as.data.frame(df_urls)
#df_urls <- read.csv("~/cagefree/Countries targeted for data collection (cage-free products web scrape) - Retailer URLs.csv")
f_commitment <- function(country2,chain2){
tmp_commitment <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"commitment"])
tmp_reporting <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"reporting"])
if(length(tmp_commitment)>1){tmp_commitment <- tmp_commitment[1]}
if(length(tmp_reporting)>1){tmp_reporting <- tmp_reporting[1]}
if(tmp_commitment & tmp_reporting){return("Has commitment and is reporting")}
if(tmp_commitment & !(tmp_reporting)){return("Has commitment but is not reporting")}
if(!(tmp_commitment) & !(tmp_reporting)){return("Has no commitment and is not reporting")}
if(!(tmp_commitment) & tmp_reporting){return("Has no commitment but is reporting")}
}
df_all_countries$commitment <- ""
for (i in c(1:nrow(df_all_countries))){
print(i)
df_all_countries$commitment[i] <- f_commitment(df_all_countries$country[i],df_all_countries$chain[i])
}
# Identify cage-free production systems
# as 1 or 0 to allow for aggregation
df_all_countries$cage_free <- ifelse(df_all_countries$production_system %in% c("barn","aviary","free-range","organic","cage-free not identified"),1,0)
# then the specific production system
df_all_countries$response_barn <- ifelse(df_all_countries$production_system == "barn",1,0)
df_all_countries$response_aviary <- ifelse(df_all_countries$production_system == "aviary",1,0)
df_all_countries$response_freerange <- ifelse(df_all_countries$production_system == "free-range",1,0)
df_all_countries$response_organic <- ifelse(df_all_countries$production_system == "organic",1,0)
df_all_countries$response_cagefreenotidentified <- ifelse(df_all_countries$production_system == "cage-free not identified",1,0)
df_all_countries$response_cage <- ifelse(df_all_countries$production_system == "cage",1,0)
df_all_countries$response_insufficientinformation <- ifelse(df_all_countries$production_system == "insufficient information",1,0)
View(df_all_countries)
# Save this data to file as the raw data table
write_csv(df_all_countries,"~/cagefree/raw_table_alltime.csv")
write_csv(df_all_countries,"~/cagefree/cagefree_site/data/raw_table_alltime.csv")
# Aggregate to calculate the number of cage-free products and products under each
# productions system, by country and chain
df_all_countries <- df_all_countries[which(df_all_countries$date=="2026-01"),]
df_agg <- aggregate(cage_free~country+chain+date,FUN=sum,data=df_all_countries)
df_agg$barn <- aggregate(response_barn~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$aviary <- aggregate(response_aviary~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$freerange <- aggregate(response_freerange~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$organic <- aggregate(response_organic~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$cagefreenotidentified <- aggregate(response_cagefreenotidentified~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$cage <- aggregate(response_cage~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$insufficientinformation <- aggregate(response_insufficientinformation~country+chain+date,FUN=sum,data=df_all_countries)[,4]
# Calculate the percent of products of each chain and country that are cage-free
df_agg$total <- aggregate(production_system~country+chain+date,FUN=length,data=df_all_countries)[,4]
df_agg$percent <- df_agg$cage_free/df_agg$total
# Sort alphabetically
df_agg <- df_agg[order(df_agg$country,df_agg$chain),]
# Do the same thing to get commitment details
df_agg$commitment <- ""
for (i in c(1:nrow(df_agg))){
df_agg$commitment[i] <- f_commitment(df_agg$country[i],df_agg$chain[i])
}
# Save to file
write_csv(df_agg,"~/cagefree/aggregate_table_alltime.csv",append=T)
write_csv(df_agg,"~/cagefree/cagefree_site/_data/aggregate_table_alltime.csv",append=T)
write_csv(df_agg,"~/cagefree/cagefree_site/data/aggregate_table_alltime.csv",append=T)
###############################
### Analysis of web scrapes ###
###############################
rm(list=ls())
# Load packages
library(scales) # For making numbers pretty
# Load in all CSV files that we saved into the data_tables folder in 01_scrape.R
data_table_files <- list.files("~/cagefree/data_tables",
full.names=T)
for (i in c(1:length(data_table_files))){
csv_tmp <- read.csv(data_table_files[i])
if(exists("df_all_countries")){
df_all_countries <- rbind(df_all_countries,csv_tmp)
} else {
df_all_countries <- csv_tmp
}
}
# Remove rows corresponding to duck eggs, quail eggs, chocolate eggs
strings_to_remove <- c("quail", "Bıldırcın", "うずら", "codorniz", "duck", "เป็ด","pato", "chocolate", "çikolat")
strings_to_remove_regex <- paste(strings_to_remove,sep="",collapse="|")
rows_to_remove <- which(grepl(strings_to_remove_regex,df_all_countries$product_name))
if(length(rows_to_remove)>0){
df_all_countries <- df_all_countries[-rows_to_remove,]
}
# List any rows that have a positive flag
# or where the production system was not given
# (which require manual review and may require manual modification of the data
# CSV files)
df_all_countries[which(df_all_countries$flag),]
df_all_countries[which(is.na(df_all_countries$production_system)),]
# Match with the original URL spreadsheet to note which countries have commitments/are reporting
df_urls <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1q4MWXWUEn3W9PY7NOmvnM1uF2Qn2qgZ7zc9hSIUiGxM/edit?gid=675609731#gid=675609731")
df_urls <- as.data.frame(df_urls)
#df_urls <- read.csv("~/cagefree/Countries targeted for data collection (cage-free products web scrape) - Retailer URLs.csv")
f_commitment <- function(country2,chain2){
tmp_commitment <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"commitment"])
tmp_reporting <- as.logical(df_urls[which(df_urls$country==country2 & df_urls$chain==chain2),"reporting"])
if(length(tmp_commitment)>1){tmp_commitment <- tmp_commitment[1]}
if(length(tmp_reporting)>1){tmp_reporting <- tmp_reporting[1]}
if(tmp_commitment & tmp_reporting){return("Has commitment and is reporting")}
if(tmp_commitment & !(tmp_reporting)){return("Has commitment but is not reporting")}
if(!(tmp_commitment) & !(tmp_reporting)){return("Has no commitment and is not reporting")}
if(!(tmp_commitment) & tmp_reporting){return("Has no commitment but is reporting")}
}
df_all_countries$commitment <- ""
for (i in c(1:nrow(df_all_countries))){
print(i)
df_all_countries$commitment[i] <- f_commitment(df_all_countries$country[i],df_all_countries$chain[i])
}
# Identify cage-free production systems
# as 1 or 0 to allow for aggregation
df_all_countries$cage_free <- ifelse(df_all_countries$production_system %in% c("barn","aviary","free-range","organic","cage-free not identified"),1,0)
# then the specific production system
df_all_countries$response_barn <- ifelse(df_all_countries$production_system == "barn",1,0)
df_all_countries$response_aviary <- ifelse(df_all_countries$production_system == "aviary",1,0)
df_all_countries$response_freerange <- ifelse(df_all_countries$production_system == "free-range",1,0)
df_all_countries$response_organic <- ifelse(df_all_countries$production_system == "organic",1,0)
df_all_countries$response_cagefreenotidentified <- ifelse(df_all_countries$production_system == "cage-free not identified",1,0)
df_all_countries$response_cage <- ifelse(df_all_countries$production_system == "cage",1,0)
df_all_countries$response_insufficientinformation <- ifelse(df_all_countries$production_system == "insufficient information",1,0)
# Save this data to file as the raw data table
write_csv(df_all_countries,"~/cagefree/raw_table_alltime.csv")
write_csv(df_all_countries,"~/cagefree/cagefree_site/data/raw_table_alltime.csv")
# Aggregate to calculate the number of cage-free products and products under each
# productions system, by country and chain
df_agg <- aggregate(cage_free~country+chain+date,FUN=sum,data=df_all_countries)
df_agg$barn <- aggregate(response_barn~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$aviary <- aggregate(response_aviary~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$freerange <- aggregate(response_freerange~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$organic <- aggregate(response_organic~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$cagefreenotidentified <- aggregate(response_cagefreenotidentified~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$cage <- aggregate(response_cage~country+chain+date,FUN=sum,data=df_all_countries)[,4]
df_agg$insufficientinformation <- aggregate(response_insufficientinformation~country+chain+date,FUN=sum,data=df_all_countries)[,4]
# Calculate the percent of products of each chain and country that are cage-free
df_agg$total <- aggregate(production_system~country+chain+date,FUN=length,data=df_all_countries)[,4]
df_agg$percent <- df_agg$cage_free/df_agg$total
# Sort alphabetically
df_agg <- df_agg[order(df_agg$country,df_agg$chain),]
# Do the same thing to get commitment details
df_agg$commitment <- ""
for (i in c(1:nrow(df_agg))){
df_agg$commitment[i] <- f_commitment(df_agg$country[i],df_agg$chain[i])
}
# Save to file
write_csv(df_agg,"~/cagefree/aggregate_table_alltime.csv",append=F)
write_csv(df_agg,"~/cagefree/cagefree_site/_data/aggregate_table_alltime.csv",append=F)
write_csv(df_agg,"~/cagefree/cagefree_site/data/aggregate_table_alltime.csv",append=F)
# Create a new table for presentation
the_month <- substr(as.character(Sys.Date()),1,7)
df_agg_presentation <- df_agg[which(df_agg$date==the_month),]
# Create a string identifying the specific production systems, to avoid having
# a million columns in the presented table
df_agg_presentation$string_of_which <- paste0("Barn = ",df_agg_presentation$barn,"<br />",
"Aviary = ",df_agg_presentation$aviary,"<br />",
"Free-range = ",df_agg_presentation$freerange,"<br />",
"Organic = ",df_agg_presentation$organic,"<br />",
"Cage-free but unidentified = ",df_agg_presentation$cagefreenotidentified,"\n")
df_agg_presentation <- df_agg_presentation[,c("country","chain","total","percent",
"cage","insufficientinformation",
"cage_free","string_of_which",
"commitment")]
# Format the table in a pretty way for online display
df_agg_presentation$percent <- percent(df_agg_presentation$percent)
names(df_agg_presentation) <- c("Country","Retail chain",
"Total egg products","Percent of products cage-free",
"Num. cage","Num. unidentified","Num. cage-free",
"...of which",
"Commitment")
# Save to file
write.csv(df_agg_presentation,"~/cagefree/aggregate_table_current.csv",row.names = F)
write.csv(df_agg_presentation,"~/cagefree/cagefree_site/data/aggregate_table_current.csv",row.names = F)
# Move all files that we have now processed to an archive for storage
data_table_move_1 <- list.files("~/cagefree/data_tables_preprocess",full.names=T)
file.rename(from=data_table_move_1,
to=gsub("cagefree/","cagefree/archive/",data_table_move_1))
data_table_move_2 <- list.files("~/cagefree/data_tables",full.names=T)
file.rename(from=data_table_move_2,
to=gsub("cagefree/","cagefree/archive/",data_table_move_2))
